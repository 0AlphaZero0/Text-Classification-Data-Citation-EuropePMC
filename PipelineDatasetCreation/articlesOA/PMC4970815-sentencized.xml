<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName JATS-journalpublishing1.dtd?><?SourceDTD.Version 39.96?><?ConverterInfo.XSLTName jp2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">PLoS One</journal-id><journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="pmc">plosone</journal-id><journal-title-group><journal-title>PLoS ONE</journal-title></journal-title-group><issn pub-type="epub">1932-6203</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, CA USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">4970815</article-id><article-id pub-id-type="pmid">27482905</article-id><article-id pub-id-type="publisher-id">PONE-D-15-39908</article-id><article-id pub-id-type="doi">10.1371/journal.pone.0157338</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and Analysis Methods</subject><subj-group><subject>Database and Informatics Methods</subject><subj-group><subject>Biological Databases</subject><subj-group><subject>Sequence Databases</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Molecular Biology</subject><subj-group><subject>Molecular Biology Techniques</subject><subj-group><subject>Sequencing Techniques</subject><subj-group><subject>Sequence Analysis</subject><subj-group><subject>Sequence Databases</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and Analysis Methods</subject><subj-group><subject>Molecular Biology Techniques</subject><subj-group><subject>Sequencing Techniques</subject><subj-group><subject>Sequence Analysis</subject><subj-group><subject>Sequence Databases</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and Analysis Methods</subject><subj-group><subject>Database and Informatics Methods</subject><subj-group><subject>Database Searching</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive Science</subject><subj-group><subject>Cognition</subject><subj-group><subject>Memory</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Learning and Memory</subject><subj-group><subject>Memory</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and Analysis Methods</subject><subj-group><subject>Database and Informatics Methods</subject><subj-group><subject>Database Searching</subject><subj-group><subject>Sequence Similarity Searching</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject><subj-group><subject>BLAST algorithm</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject><subj-group><subject>BLAST algorithm</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Database and informatics methods</subject><subj-group><subject>Bioinformatics</subject><subj-group><subject>Software-aided sequence analysis</subject><subj-group><subject>BLAST algorithm</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical Sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Optimization</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and Information Sciences</subject><subj-group><subject>Computer Architecture</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and Life Sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Genomics</subject><subj-group><subject>Metagenomics</subject></subj-group></subj-group></subj-group></subj-group></article-categories><title-group><article-title><SecTag type="TITLE"><text><SENT sid="0" pm="."><plain>GPU-Acceleration of Sequence Homology Searches with Database Subsequence Clustering </plain></SENT>
</text></SecTag></article-title><alt-title alt-title-type="running-head">GPU-Acceleration of Sequence Homology Searches</alt-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Suzuki</surname><given-names>Shuji</given-names></name><xref ref-type="aff" rid="aff001"><sup>1</sup></xref><xref ref-type="aff" rid="aff002"><sup>2</sup></xref></contrib><contrib contrib-type="author"><name><surname>Kakuta</surname><given-names>Masanori</given-names></name><xref ref-type="aff" rid="aff001"><sup>1</sup></xref></contrib><contrib contrib-type="author"><name><surname>Ishida</surname><given-names>Takashi</given-names></name><xref ref-type="aff" rid="aff001"><sup>1</sup></xref><xref ref-type="aff" rid="aff002"><sup>2</sup></xref></contrib><contrib contrib-type="author"><name><surname>Akiyama</surname><given-names>Yutaka</given-names></name><xref ref-type="aff" rid="aff001"><sup>1</sup></xref><xref ref-type="aff" rid="aff002"><sup>2</sup></xref><xref ref-type="corresp" rid="cor001">*</xref></contrib></contrib-group><aff id="aff001">
<label>1</label>
<addr-line>Graduate School of Information Science and Engineering, Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan</addr-line>
</aff><aff id="aff002">
<label>2</label>
<addr-line>Education Academy of Computational Life Sciences (ACLS), Tokyo Institute of Technology, Meguro-ku, Tokyo, Japan</addr-line>
</aff><contrib-group><contrib contrib-type="editor"><name><surname>von Haeseler</surname><given-names>Arndt</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">
<addr-line>Max F. Perutz Laboratories, AUSTRIA</addr-line>
</aff><author-notes><fn fn-type="COI-statement" id="coi001"><p><text><SENT sid="1" pm="."><plain>Competing Interests: The authors have declared that no competing interests exist. </plain></SENT>
</text></p></fn><fn fn-type="con"><p><text><SENT sid="2" pm="."><plain>Conceived and designed the experiments: SS MK TI YA.Performed the experiments: SS.Analyzed the data: SS.Contributed reagents/materials/analysis tools: SS MK.Wrote the paper: SS MK TI YA. </plain></SENT>
</text></p></fn><corresp id="cor001">* E-mail: <email>akiyama@cs.titech.ac.jp</email></corresp></author-notes><pub-date pub-type="collection"><year>2016</year></pub-date><pub-date pub-type="epub"><day>2</day><month>8</month><year>2016</year></pub-date><volume>11</volume><issue>8</issue><elocation-id>e0157338</elocation-id><history><date date-type="received"><day>9</day><month>9</month><year>2015</year></date><date date-type="accepted"><day>27</day><month>5</month><year>2016</year></date></history><permissions><copyright-statement>© 2016 Suzuki et al</copyright-statement><copyright-year>2016</copyright-year><copyright-holder>Suzuki et al</copyright-holder><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><self-uri content-type="pdf" xlink:href="pone.0157338.pdf"/><abstract><p><SecTag type="ABS"><text><SENT sid="3" pm="."><plain>Sequence homology searches are used in various fields and require large amounts of computation time, especially for metagenomic analysis, owing to the large number of queries and the database size. </plain></SENT>
<SENT sid="4" pm="."><plain>To accelerate computing analyses, graphics processing units (GPUs) are widely used as a low-cost, high-performance computing platform. </plain></SENT>
<SENT sid="5" pm="."><plain>Therefore, we mapped the time-consuming steps involved in GHOSTZ, which is a state-of-the-art homology search algorithm for protein sequences, onto a GPU and implemented it as GHOSTZ-GPU. </plain></SENT>
<SENT sid="6" pm="."><plain>In addition, we optimized memory access for GPU calculations and for communication between the CPU and GPU. </plain></SENT>
<SENT sid="7" pm="."><plain>As per results of the evaluation test involving metagenomic data, GHOSTZ-GPU with 12 CPU threads and 1 GPU was approximately 3.0- to 4.1-fold faster than GHOSTZ with 12 CPU threads. </plain></SENT>
<SENT sid="8" pm="."><plain>Moreover, GHOSTZ-GPU with 12 CPU threads and 3 GPUs was approximately 5.8- to 7.7-fold faster than GHOSTZ with 12 CPU threads. </plain></SENT>
</text></SecTag></p></abstract><funding-group><award-group id="award001"><funding-source><institution-wrap><institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100001691</institution-id><institution>Japan Society for the Promotion of Science</institution></institution-wrap></funding-source><award-id>248766</award-id><principal-award-recipient><name><surname>Suzuki</surname><given-names>Shuji</given-names></name></principal-award-recipient></award-group><award-group id="award002"><funding-source><institution>MEXT SPIRE Supercomputational Life Science</institution></funding-source><principal-award-recipient><name><surname>Akiyama</surname><given-names>Yutaka</given-names></name></principal-award-recipient></award-group><award-group id="award003"><funding-source><institution>National Cancer Center</institution></funding-source><principal-award-recipient><name><surname>Akiyama</surname><given-names>Yutaka</given-names></name></principal-award-recipient></award-group><funding-statement>This work was supported by a Grant-in-Aid for the Japan Society for the Promotion of Science Fellows (Grant number 248766) to SS, the Strategic Programs for Innovative Research Field 1 Supercomputational Life Science of the Ministry of Education, Culture, Sports, Science and Technology of Japan to YA, and Cancer Research Development funding from the National Cancer Center of Japan to YA.</funding-statement></funding-group><counts><fig-count count="13"/><table-count count="5"/><page-count count="22"/></counts><custom-meta-group><custom-meta id="data-availability"><meta-name>Data Availability</meta-name><meta-value>Sequencing data of soil metagenome and marine metagenome are available from International Nucleotide Sequence Database Collaboration partners (DDBJ (<ext-link ext-link-type="uri" xlink:href="http://www.ddbj.nig.ac.jp/">http://www.ddbj.nig.ac.jp/</ext-link>), EMBL-EBI (<ext-link ext-link-type="uri" xlink:href="https://www.ebi.ac.uk/">https://www.ebi.ac.uk/</ext-link>), and NCBI (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/)">http://www.ncbi.nlm.nih.gov/)</ext-link>) with accession numbers SRR407548 and ERR315856. Sequencing data of human metagenome is available from HMP-DACC (<ext-link ext-link-type="uri" xlink:href="http://hmpdacc.org/">http://hmpdacc.org/</ext-link>) with accession number SRS011098.</meta-value></custom-meta></custom-meta-group></article-meta><notes><title>Data Availability</title><p>Sequencing data of soil metagenome and marine metagenome are available from International Nucleotide Sequence Database Collaboration partners (DDBJ (<ext-link ext-link-type="uri" xlink:href="http://www.ddbj.nig.ac.jp/">http://www.ddbj.nig.ac.jp/</ext-link>), EMBL-EBI (<ext-link ext-link-type="uri" xlink:href="https://www.ebi.ac.uk/">https://www.ebi.ac.uk/</ext-link>), and NCBI (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/)">http://www.ncbi.nlm.nih.gov/)</ext-link>) with accession numbers SRR407548 and ERR315856. Sequencing data of human metagenome is available from HMP-DACC (<ext-link ext-link-type="uri" xlink:href="http://hmpdacc.org/">http://hmpdacc.org/</ext-link>) with accession number SRS011098.</p></notes></front><body><SecTag type="INTRO"><sec sec-type="intro" id="sec001"><title><text><SENT sid="9" pm="."><plain>Introduction </plain></SENT>
</text></title><p><text><SENT sid="10" pm="."><plain>Sequence homology search is widely used in bioinformatics. </plain></SENT>
<SENT sid="11" pm="."><plain>This method is needed to identify evolutionary relations among sequences. </plain></SENT>
<SENT sid="12" pm="."><plain>It can also be used to estimate possible functions and structures of DNA and proteins. </plain></SENT>
<SENT sid="13" pm="."><plain>Nonetheless, sequence homology searches have become a major bottleneck of such analyses, especially metagenomic analyses, because of the increasing number of queries and database size. </plain></SENT>
</text></p><p><text><SENT sid="14" pm="."><plain>In a metagenomic analysis, environmental samples frequently include DNA sequences from several species, and the reference database often does not contain closely related homologous sequences. </plain></SENT>
<SENT sid="15" pm="."><plain>Therefore, a sequence homology search is used to identify novel genes in these samples. </plain></SENT>
<SENT sid="16" pm="."><plain>In a typical metagenomic analysis, reads are translated into protein-coding sequences and assigned to protein families by means of a homology search in publicly available databases such as the Kyoto Encyclopedia of Genes and Genomes (KEGG) [1, 2], COG [3, 4] and Pfam [5]. </plain></SENT>
<SENT sid="17" pm="."><plain>The BLASTX software [6, 7] is commonly used for such binning and classification searches. </plain></SENT>
<SENT sid="18" pm="."><plain>To identify homologs that may not have high identity of nucleotide sequences, BLASTX translates nucleotide sequences into protein sequences because such sequences are often more similar than the original nucleotide sequences [8, 9]. </plain></SENT>
<SENT sid="19" pm="."><plain>Nonetheless, the search speed of BLASTX is insufficient for analysis of large quantities of sequence data now available. </plain></SENT>
<SENT sid="20" pm="."><plain>For instance, sequence homology searches for metagenomic data produced by HiSeq2500, which is one of the latest DNA sequencers, require approximately 100,000 days with BLASTX on a single workstation containing 12 CPU cores. </plain></SENT>
</text></p><p><text><SENT sid="21" pm="."><plain>Developers of several homology search tools currently available, such as RAPSearch [10, 11], GHOSTX [12], GHOSTZ [13], and DIAMOND[14], claim that their tools search faster than BLASTX, without a significant decrease in search sensitivity. </plain></SENT>
<SENT sid="22" pm="."><plain>GHOSTZ is one of the fastest homology search tools. </plain></SENT>
<SENT sid="23" pm="."><plain>It uses the database subsequence clustering method. </plain></SENT>
<SENT sid="24" pm="."><plain>This method clusters similar subsequences from a database to perform an efficient seed search and ungapped extension by reducing the number of alignment candidates on the basis of triangle inequality. </plain></SENT>
<SENT sid="25" pm="."><plain>GHOSTZ achieved a 2-fold increase in speed, without a substantial decrease in search sensitivity, as compared to GHOSTZ without the database subsequence clustering method. </plain></SENT>
<SENT sid="26" pm="."><plain>Originally, GHOSTZ was approximately 2.2–2.8 times faster than RAPSearch and approximately 185–261 times faster than BLASTX. </plain></SENT>
<SENT sid="27" pm="."><plain>Nevertheless, the sequencing technology has since improved and bigger sequence data can now be obtained. </plain></SENT>
<SENT sid="28" pm="."><plain>Therefore, the speed of homology searches needs a further increase to facilitate efficient metagenomic analysis. </plain></SENT>
</text></p><p><text><SENT sid="29" pm="."><plain>To accelerate computing analyses, graphics processing units (GPUs) are widely used as a low-cost high-performance computing platform. </plain></SENT>
<SENT sid="30" pm="."><plain>Among top-level supercomputers worldwide, several systems incorporate multiple CPU cores and GPUs within a node, as in TSUBAME 2.5 of the Tokyo Institute of Technology. </plain></SENT>
<SENT sid="31" pm="."><plain>GPUs have greater computational power and memory bandwidth than CPUs do. </plain></SENT>
<SENT sid="32" pm="."><plain>Recently, several bioinformatic tools have been enhanced by means of GPUs [15–17]. </plain></SENT>
</text></p><p><text><SENT sid="33" pm="."><plain>Several tools for sequence homology searches on the basis of GPUs have also been developed. </plain></SENT>
<SENT sid="34" pm="."><plain>They are roughly classified into 2 types: implementation of the Smith-Waterman algorithm [18] and a seed-and-extend algorithm such as BLAST. </plain></SENT>
<SENT sid="35" pm="."><plain>GPU accelerated Smith-Waterman algorithms [19–21] and seed-and-extend algorithms for DNA sequences [22, 23] were several times faster than those of implementation for CPU with multiple CPU cores. </plain></SENT>
<SENT sid="36" pm="."><plain>SW#db [20] is one of the GPU-based Smith-Waterman algorithms, and showed that when it is based on 1 GPU, it works 4- to 5-fold faster than does SSEARCH [24], which is a CPU-based Smith-Waterman algorithm, with 4 CPU cores. </plain></SENT>
<SENT sid="37" pm="."><plain>G-BLASTN [22] is one of the GPU-based BLAST with 1 GPU achieves 7.2-fold acceleration relative to the MEGABLAST mode of NCBI-BLAST [25] with 4 CPU cores and 1.6-fold acceleration relative to the BLASTN mode of NCBI-BLAST with 4 CPU cores. </plain></SENT>
<SENT sid="38" pm="."><plain>On the other hand, GPU accelerated seed-and-extend algorithms for protein sequences, such as GPU-BLAST [26] and CUDA-BLASTP[27], achieved limited success. </plain></SENT>
<SENT sid="39" pm="."><plain>GPU-BLAST [26] and CUDA-BLASTP[27] with 1 GPU achieve 6-fold and 5- to 6-fold acceleration, respectively, relative to the BLASTP mode of NCBI-BLAST with a single CPU core. </plain></SENT>
<SENT sid="40" pm="."><plain>These results mean that the acceleration of GPU-BLAST or CUDA-BLASTP with 1 GPU is estimated to be less than 1.5-fold as compared to NCBI-BLAST with a single CPU socket with 4 CPU cores. </plain></SENT>
<SENT sid="41" pm="."><plain>Therefore, mapping an algorithm of a protein sequence homology search onto GPUs is still a challenging task. </plain></SENT>
<SENT sid="42" pm="."><plain>In addition, faster algorithms of protein sequence homology searches than BLAST have not yet been mapped onto GPUs. </plain></SENT>
</text></p><p><text><SENT sid="43" pm="."><plain>In this study, we mapped the GHOSTZ algorithm onto GPUs to accelerate sequence homology searches. </plain></SENT>
<SENT sid="44" pm="."><plain>This task was more challenging than GPU implementation of BLASTX because GHOSTZ is faster than BLASTX. </plain></SENT>
<SENT sid="45" pm="."><plain>We introduced several speed-up methods in addition to simple GPU mapping of the algorithm. </plain></SENT>
<SENT sid="46" pm="."><plain>To accelerate a sequence homology search on GPUs, we optimized access of the data in the GPU memory. </plain></SENT>
<SENT sid="47" pm="."><plain>Moreover, we reduced the waiting time for synchronization to attain full use of a computing environment by setting up GHOSTZ-GPU to reduce inactive threads in gapped extension and to use asynchronous execution on CPU and GPU. </plain></SENT>
<SENT sid="48" pm="."><plain>GHOSTZ-GPU was implemented in C++ and CUDA 6.0. </plain></SENT>
<SENT sid="49" pm="."><plain>It is distributed under the BSD 2-clause license and is available for download at <ext-link ext-link-type="uri" xlink:href="https://github.com/akiyamalab/ghostz-gpu">https://github.com/akiyamalab/ghostz-gpu</ext-link>. </plain></SENT>
</text></p></sec></SecTag><SecTag type="METHODS"><sec sec-type="materials|methods" id="sec002"><title><text><SENT sid="50" pm="."><plain>Methods </plain></SENT>
</text></title><sec id="sec003"><title><text><SENT sid="51" pm="."><plain>GHOSTZ </plain></SENT>
</text></title><p><text><SENT sid="52" pm="."><plain>The workflow of GHOSTZ is shown in Fig 1. </plain></SENT>
<SENT sid="53" pm="."><plain>The GHOSTZ protocol consists of 5 main steps: seed search, similarity filtering, ungapped extension, chain filtering, and gapped extension. </plain></SENT>
<SENT sid="54" pm="."><plain>To accelerate the sequence homology search with the GHOSTZ algorithm, subsequences are extracted from database sequences and similar subsequences are clustered during preprocessing for the sequence homology search. </plain></SENT>
<SENT sid="55" pm="."><plain>Subsequently, hash tables are constructed containing indexes for the subsequences within database sequences. </plain></SENT>
<SENT sid="56" pm="."><plain>GHOSTZ uses the hash tables to select seeds for the alignments from representative sequences in the clusters. </plain></SENT>
<SENT sid="57" pm="."><plain>In the sequence homology search, the seed search process selects seeds that are subsequences of database sequences similar to those of the query sequence. </plain></SENT>
<SENT sid="58" pm="."><plain>Similarity filtering is then performed to reduce the number of seeds, whereby the distance between a query subsequence and the cluster representative is calculated, and the lower bounds of the distance between the query subsequence and other members of the cluster are computed on the basis of triangle inequality. </plain></SENT>
<SENT sid="59" pm="."><plain>If the computed lower bound is lower than or equal to the distance threshold, then the seed is taken to the next step, that is, the ungapped extension, to assess the homology between the query and the member sequences of the cluster. </plain></SENT>
<SENT sid="60" pm="."><plain>Finally, chain filtering is used to bring similar extended seeds together, and gapped extension is performed to obtain an alignment from the extended seed that contains gaps. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g001</object-id><label>Fig 1</label><caption><title><text><SENT sid="61" pm="."><plain>The workflow of GHOSTZ. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g001"/></fig></SecTag><p><text><SENT sid="62" pm="."><plain>The GHOSTZ system has several limitations. Table 1 shows the ratio of calculation time for each step of GHOSTZ. </plain></SENT>
<SENT sid="63" pm="."><plain>The ungapped-extension step requires most (44.3%) of the total calculation time. </plain></SENT>
<SENT sid="64" pm="."><plain>Nonetheless, mapping of an ungapped extension onto GPUs by itself is insufficient for improvement of the search speed. </plain></SENT>
<SENT sid="65" pm="."><plain>This is because other calculations also require considerable time, for example, gapped extension and the distance calculation, which is a subprocess of similarity filtering. </plain></SENT>
</text></p><SecTag type="TABLE"><table-wrap id="pone.0157338.t001" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.t001</object-id><label>Table 1</label><caption><title><text><SENT sid="66" pm="."><plain>Average and standard deviation of computation time of each component of a GHOSTZ calculation with 1 CPU thread. </plain></SENT>
</text></title></caption><alternatives><graphic id="pone.0157338.t001g" xlink:href="pone.0157338.t001"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1"><text><SENT sid="67" pm="."><plain>CPU Time (sec.) </plain></SENT>
</text></th><th align="left" rowspan="1" colspan="1"><text><SENT sid="68" pm="."><plain>Ratio (%) </plain></SENT>
</text></th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="69" pm="."><plain>Distance calculation </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="70" pm="."><plain>1340.7 ± 45.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="71" pm="."><plain>3.2 ± 0.0 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="72" pm="."><plain>Ungapped Extension </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="73" pm="."><plain>18554.8 ± 695.8 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="74" pm="."><plain>44.3 ± 0.1 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="75" pm="."><plain>Gapped Extension </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="76" pm="."><plain>17191.5 ± 672.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="77" pm="."><plain>41.1 ± 0.2 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="78" pm="."><plain>Others </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="79" pm="."><plain>4772.6 ± 116.5 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="80" pm="."><plain>11.4 ± 0.3 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="81" pm="."><plain>Total </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="82" pm="."><plain>41859.6 ± 1499.1 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="83" pm="."><plain>100.0 ± 0.0 </plain></SENT>
</text></td></tr></tbody></table></alternatives><table-wrap-foot><fn id="t001fn001"><p><text><SENT sid="84" pm="."><plain>This profile was obtained from the calculation involving 1,000,000 short DNA reads in metagenomic sequences of a soil microbiome (accession number SRR407548, read length 150 bp) as queries and KEGG GENES (as of May 2013) as the database. </plain></SENT>
<SENT sid="85" pm="."><plain>The reads were randomly selected from dataset SRR407548. </plain></SENT>
<SENT sid="86" pm="."><plain>The profile was obtained on a workstation with a single CPU core of 2.93 GHz (Intel Xeon 5670 processor) and 54 GB of memory. </plain></SENT>
<SENT sid="87" pm="."><plain>GHOSTZ was compiled by means of GCC (version 4.3.4) with the -O3 optimization option. </plain></SENT>
<SENT sid="88" pm="."><plain>To obtain a profile, the functions of distance calculation, ungapped extension, and gapped extension were not in-lined. </plain></SENT>
<SENT sid="89" pm="."><plain>This experiment was repeated 5 times. </plain></SENT>
</text></p></fn></table-wrap-foot></table-wrap></SecTag></sec><sec id="sec004"><title><text><SENT sid="90" pm="."><plain>GPU Implementation Overview </plain></SENT>
</text></title><p><text><SENT sid="91" pm="."><plain>To improve the search speed of GHOSTZ with GPUs, the mapping of the steps, including distance calculation, ungapped extension, and gapped extension, onto GPUs is evidently crucial for achievement of effective acceleration. </plain></SENT>
<SENT sid="92" pm="."><plain>Therefore, we mapped these steps onto GPUs. </plain></SENT>
<SENT sid="93" pm="."><plain>Current computing systems often have multiple CPU cores and multiple GPUs in a computing node. </plain></SENT>
<SENT sid="94" pm="."><plain>Therefore, we focused on a computing node with multiple CPU cores and multiple GPUs. </plain></SENT>
<SENT sid="95" pm="."><plain>For the GPU implementation, we used NVIDIA’s CUDA 6.0. </plain></SENT>
</text></p><p><text><SENT sid="96" pm="."><plain>The CUDA software contains a function (performed on a GPU) called a kernel. </plain></SENT>
<SENT sid="97" pm="."><plain>It represents the operations to be launched by a single CPU thread and is invoked as a set of concurrently executed GPU threads. </plain></SENT>
<SENT sid="98" pm="."><plain>These threads are organized in a hierarchy consisting of thread blocks and grids. </plain></SENT>
<SENT sid="99" pm="."><plain>A thread block is a set of concurrent threads, and a grid is a set of independent thread blocks. </plain></SENT>
<SENT sid="100" pm="."><plain>The kernel uses several types of memory, such as global memory, local memory, shared memory, and registers. </plain></SENT>
<SENT sid="101" pm="."><plain>Global memory is used for communication between a CPU and GPU. </plain></SENT>
<SENT sid="102" pm="."><plain>Local memory stores local variables of a thread when a register is not used. </plain></SENT>
<SENT sid="103" pm="."><plain>Although global and local memory are larger than other memory types in the GPU, access to them is slow. </plain></SENT>
<SENT sid="104" pm="."><plain>Therefore, it is important for GPU calculations to reduce the number of accesses to these memory types, often via the use of shared memory, to which the access is faster than to either global or local memory. </plain></SENT>
<SENT sid="105" pm="."><plain>Shared memory is also used to communicate among threads in a block. </plain></SENT>
<SENT sid="106" pm="."><plain>However, it is smaller than either global or local memory. </plain></SENT>
<SENT sid="107" pm="."><plain>Therefore, it is used as a software cache. </plain></SENT>
</text></p><p><text><SENT sid="108" pm="."><plain>Simply mapping the distance calculation, ungapped extension, and gapped extension onto a GPU is insufficient for acceleration of GHOSTZ. </plain></SENT>
<SENT sid="109" pm="."><plain>It involves a number of accesses to global memory, the large inactive threads in a GPU, and the lengthy computation time of other CPU calculations. </plain></SENT>
<SENT sid="110" pm="."><plain>Therefore, we applied 4 main optimizations: memory access for sequence data, memory access for dynamic programing (DP) matrices and load balancing in gapped extension, asynchronous execution on the CPU and GPU, and addition of a special thread for loading the database. </plain></SENT>
</text></p></sec><sec id="sec005"><title><text><SENT sid="111" pm="."><plain>Optimization of the Distance Calculation </plain></SENT>
</text></title><p><text><SENT sid="112" pm="."><plain>The distance calculation is a part of similarity filtering. </plain></SENT>
<SENT sid="113" pm="."><plain>Distance calculations are independent of each other. </plain></SENT>
<SENT sid="114" pm="."><plain>Therefore, these calculations can be performed within different GPU threads. </plain></SENT>
<SENT sid="115" pm="."><plain>Nevertheless, when each thread executes a different task in a block, the memory access for the query or database sequence is random. </plain></SENT>
<SENT sid="116" pm="."><plain>These memory accesses take a long computational time. </plain></SENT>
<SENT sid="117" pm="."><plain>Therefore, it is important to utilize efficiency of the GPU to reduce the number of random accesses to global memory for sequence data. </plain></SENT>
<SENT sid="118" pm="."><plain>We use 2 approaches to reduce the number of random accesses: “vectorized memory access” and “group memory access”. </plain></SENT>
</text></p><p><text><SENT sid="119" pm="."><plain>A character in a protein sequence is represented by 5 bits in GHOSTZ-GPU because the alphabet size for a protein is 20. </plain></SENT>
<SENT sid="120" pm="."><plain>Therefore, an 8-bit memory module is sufficient for each character in the sequence. </plain></SENT>
<SENT sid="121" pm="."><plain>On the other hand, if 8 bits are used for character access, then a large number of accesses to global memory are required for the protein sequence. </plain></SENT>
<SENT sid="122" pm="."><plain>To solve this problem, vectorized load instruction (64- or 128-bit access) is often used to reduce the number of global memory accesses and is called “vectorized memory access” in CUDA programming. </plain></SENT>
<SENT sid="123" pm="."><plain>When we use this memory access method, the accessed data have to be assigned to a consecutive region in global memory. </plain></SENT>
<SENT sid="124" pm="."><plain>Suppose w is the number of characters to be accessed once and l is the length of the sequence for calculation. </plain></SENT>
<SENT sid="125" pm="."><plain>With this memory access, the number of accesses to global memory is ⌈(l + w − 1)/w⌉. </plain></SENT>
<SENT sid="126" pm="."><plain>In GHOSTZ-GPU, the sequence data are allocated to consecutive regions in global memory. </plain></SENT>
<SENT sid="127" pm="."><plain>The sequences in a database are connected with inserted delimiters to transform them into a long single sequence. </plain></SENT>
<SENT sid="128" pm="."><plain>Query sequences are connected in the same manner as database sequences are. </plain></SENT>
<SENT sid="129" pm="."><plain>Therefore, GHOSTZ-GPU can use vectorized memory access for sequence data. </plain></SENT>
<SENT sid="130" pm="."><plain>GHOSTZ-GPU uses 64-bit access to protein sequences. </plain></SENT>
<SENT sid="131" pm="."><plain>In distance calculations, the length of the sequence used l is 10. </plain></SENT>
<SENT sid="132" pm="."><plain>In the GPU, the bit size of a character is 5. </plain></SENT>
<SENT sid="133" pm="."><plain>Therefore, when GHSOTZ-GPU uses 64-bit memory access, w is 12. </plain></SENT>
<SENT sid="134" pm="."><plain>In this case, the number of memory accesses for sequence data is 2. </plain></SENT>
</text></p><p><text><SENT sid="135" pm="."><plain>Moreover, we propose “group memory access” to speed up global memory access. </plain></SENT>
<SENT sid="136" pm="."><plain>For group memory access, we subdivided threads in a block into small groups. </plain></SENT>
<SENT sid="137" pm="."><plain>Then, the threads in a group load the data with communication among them. </plain></SENT>
<SENT sid="138" pm="."><plain>The threads in a group access one consecutive region at a time in global memory. </plain></SENT>
<SENT sid="139" pm="."><plain>These memory accesses are merged into a single transaction in a GPU, called coalesced memory access, which is used when threads in a block access the same region in global memory. </plain></SENT>
<SENT sid="140" pm="."><plain>With coalesced memory access for sequence data, the number of memory accesses for sequence data is reduced. </plain></SENT>
<SENT sid="141" pm="."><plain>The threads that have the same group ID are combined into 1 group. </plain></SENT>
<SENT sid="142" pm="."><plain>The group ID is calculated as follows. </plain></SENT>
<SENT sid="143" pm="."><plain>If ithread is the thread ID and Nmember is the number of threads in a group, then let us assume that igroup = ⌊ithread/Nmember⌋ is the group ID of the thread ithread. </plain></SENT>
<SENT sid="144" pm="."><plain>Examples of memory access with and without group memory access are shown in Fig 2. </plain></SENT>
<SENT sid="145" pm="."><plain>For group memory access, we used shared memory to temporarily store sequence data and for communication among threads in a group. </plain></SENT>
<SENT sid="146" pm="."><plain>The number of accesses to global memory decreases with the use of this memory. </plain></SENT>
<SENT sid="147" pm="."><plain>In the distance calculation, the number of threads in a group Nmember is 2. l and w have the same value as with vectorized memory access. </plain></SENT>
<SENT sid="148" pm="."><plain>In this case, the minimal number of memory accesses with group memory access is only 1. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g002</object-id><label>Fig 2</label><caption><title><text><SENT sid="149" pm="."><plain>Examples of sequence data accesses. </plain></SENT>
</text></title><p><text><SENT sid="150" pm="."><plain>A) An example of sequence data accesses without group memory access. </plain></SENT>
<SENT sid="151" pm="."><plain>B) An example of sequence data accesses with group memory access. </plain></SENT>
</text></p></caption><graphic xlink:href="pone.0157338.g002"/></fig></SecTag><p><text><SENT sid="152" pm="."><plain>Moreover, the distance calculation also has memory access to global memory for the positions of seeds. </plain></SENT>
<SENT sid="153" pm="."><plain>In addition, the memory access for the postion of a seed is required for coalesced memory access to reduce the number of global memory accesses. </plain></SENT>
<SENT sid="154" pm="."><plain>The positions of a seed are a query position and database position. </plain></SENT>
<SENT sid="155" pm="."><plain>We use the structure of array for the positions of seeds to use coalesced memory access for these data. </plain></SENT>
<SENT sid="156" pm="."><plain>The structure of an array is often used for coalesced memory access in the structure of GPU computing. </plain></SENT>
</text></p><p><text><SENT sid="157" pm="."><plain>Fig 3 shows a pseudocode for distance calculation. </plain></SENT>
<SENT sid="158" pm="."><plain>The subsequences are loaded into shared memory from global memory with vectorized memory access and group memory access (lines 14 and 15 in Fig 3). </plain></SENT>
<SENT sid="159" pm="."><plain>After that, the distance between the query subsequence and database subsequence is calculated. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g003</object-id><label>Fig 3</label><caption><title><text><SENT sid="160" pm="."><plain>The pseudocode of distance calculation. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g003"/></fig></SecTag><p><text><SENT sid="161" pm="."><plain>Using these optimizations, we reduced the number of global memory accesses. </plain></SENT>
</text></p></sec><sec id="sec006"><title><text><SENT sid="162" pm="."><plain>Optimization of Ungapped Extension </plain></SENT>
</text></title><p><text><SENT sid="163" pm="."><plain>Most of homology search algorithms perform ungapped extension before gapped extension to reduce the number of candidates because gapped extension generally requires a lot of computation time. </plain></SENT>
<SENT sid="164" pm="."><plain>Because ungapped extensions are independent of each other, these calculations can also be performed in different GPU threads. </plain></SENT>
</text></p><p><text><SENT sid="165" pm="."><plain>Ungapped extension requires a number of memory accesses for sequence data and the positions of seeds. </plain></SENT>
<SENT sid="166" pm="."><plain>We use vectorized memory access, group memory access, and the structure of an array for the positions of seeds during ungapped extension, as in distance calculation. </plain></SENT>
<SENT sid="167" pm="."><plain>On the other hand, the use of group memory access to all sequence data leads to performance degradation because the lengths of extensions vary (X-dropoff [6, 7] is used [13] for extensions). </plain></SENT>
<SENT sid="168" pm="."><plain>The threads that finish ungapped extensions wait for the other threads. </plain></SENT>
<SENT sid="169" pm="."><plain>Thus, we use group memory access only for the first memory access for each sequence. </plain></SENT>
<SENT sid="170" pm="."><plain>The number of members in a group is 4. </plain></SENT>
<SENT sid="171" pm="."><plain>If more memory accesses are required, GHOSTZ-GPU uses only vectorized memory access for the remaining sequence data. </plain></SENT>
</text></p><p><text><SENT sid="172" pm="."><plain>Fig 4 shows a pseudocode for ungapped extension of the rightward on a GPU. </plain></SENT>
<SENT sid="173" pm="."><plain>Ungapped extension of the leftward on a GPU is almost the same as ungapped extension of the rightward on a GPU. </plain></SENT>
<SENT sid="174" pm="."><plain>The subsequences are loaded into shared memory from global memory with vectorized memory access and group memory access (lines 15 and 16 in Fig 4). </plain></SENT>
<SENT sid="175" pm="."><plain>Then, the ungapped-extension score between the query subsequence and database subsequence is calculated. </plain></SENT>
<SENT sid="176" pm="."><plain>If the ungapped extension is not terminated in line 17 of Fig 4, then the ungapped extension is continued until its termination (lines 23–30 in Fig 4). </plain></SENT>
<SENT sid="177" pm="."><plain>The lengths of this loop are different for every seed. </plain></SENT>
<SENT sid="178" pm="."><plain>Thus, group memory access is not used in this loop (lines 24 and 25 in Fig 4). </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g004</object-id><label>Fig 4</label><caption><title><text><SENT sid="179" pm="."><plain>The pseudocode of ungapped extension. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g004"/></fig></SecTag></sec><sec id="sec007"><title><text><SENT sid="180" pm="."><plain>Optimization of Gapped Extension </plain></SENT>
</text></title><p><text><SENT sid="181" pm="."><plain>During gapped extension, the seeds are extended with gaps. </plain></SENT>
<SENT sid="182" pm="."><plain>Gapped extensions are independent of each other. </plain></SENT>
<SENT sid="183" pm="."><plain>Therefore, these calculations can be performed in different GPU threads. </plain></SENT>
<SENT sid="184" pm="."><plain>There are 2 main reasons why gapped extension increases computation time in a GPU calculation: the access to global memory and branch divergence. </plain></SENT>
</text></p><p><text><SENT sid="185" pm="."><plain>Gapped extension mainly involves memory accesses for sequence data, the positions of seeds, and the DP matrix. </plain></SENT>
<SENT sid="186" pm="."><plain>Memory accesses of gapped extensions for sequence data and the positions of seeds are also optimized in the same manner as for ungapped extensions. Fig 5 shows a pseudocode for gapped extension of the rightward on a GPU. </plain></SENT>
<SENT sid="187" pm="."><plain>Gapped extension of the leftward on a GPU is almost the same as gapped extension of the rightward on the GPU. </plain></SENT>
<SENT sid="188" pm="."><plain>The subsequences are loaded from global memory with vectorized memory access and group memory access (lines 15 and 19 in Fig 5). </plain></SENT>
<SENT sid="189" pm="."><plain>The remaining sequence data are loaded with vectorized memory access (lines 17 and 25 in Fig 5). </plain></SENT>
<SENT sid="190" pm="."><plain>After loading the sequence data, we calculate the score from these sequence data. </plain></SENT>
<SENT sid="191" pm="."><plain>If the gapped extension is not terminated in line 21 of Fig 5, then the gapped extension is continued until the termination (lines 24–29 in Fig 5). </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g005" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g005</object-id><label>Fig 5</label><caption><title><text><SENT sid="192" pm="."><plain>The pseudocode of gapped extension. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g005"/></fig></SecTag><p><text><SENT sid="193" pm="."><plain>In addition, memory accesses for the DP matrix in gap extensions also require a lengthy computation time. </plain></SENT>
<SENT sid="194" pm="."><plain>Each cell in the DP matrix is computed by other cells, and the greatest value of a cell is termed “the score” in gapped extension. </plain></SENT>
<SENT sid="195" pm="."><plain>When we calculate a gapped-alignment score only, we do not need to store all data in the DP matrix. </plain></SENT>
<SENT sid="196" pm="."><plain>Thus, GHOSTZ-GPU stores only 1 column of the DP matrix in local memory of the GPU in the same way as BLAST does [7]. </plain></SENT>
<SENT sid="197" pm="."><plain>The length of a column in the DP matrix depends on the query length, which is generally shorter than the database sequence in current metagenomic analyses. </plain></SENT>
<SENT sid="198" pm="."><plain>Local memory in a GPU is slower than a register or shared memory. </plain></SENT>
<SENT sid="199" pm="."><plain>For acceleration of the gapped-extension process, we have to reduce the number of accesses to local memory. </plain></SENT>
<SENT sid="200" pm="."><plain>This task is accomplished by adding another loop to those used to calculate gapped extension and by recruiting shared memory for this loop. </plain></SENT>
<SENT sid="201" pm="."><plain>The calculation workflows of GHOSTZ and GHOSTZ-GPU during gapped extension are shown in Fig 6. </plain></SENT>
<SENT sid="202" pm="."><plain>The loop length k in GHOSTZ-GPU is 4. </plain></SENT>
<SENT sid="203" pm="."><plain>This loop requires additional memory access for this loop. </plain></SENT>
<SENT sid="204" pm="."><plain>Nevertheless, the required data for this loop can be assigned to shared memory. </plain></SENT>
<SENT sid="205" pm="."><plain>Therefore, the memory accesses for this loop are quick. </plain></SENT>
<SENT sid="206" pm="."><plain>The shared memory during gapped extension is reused as in group memory access. </plain></SENT>
<SENT sid="207" pm="."><plain>Thus, the additional shared memory allocations for this loop are not needed. </plain></SENT>
<SENT sid="208" pm="."><plain>With this optimization, the search results with GHOSTZ-GPU may be different from those with GHOSTZ. </plain></SENT>
<SENT sid="209" pm="."><plain>The gapped extension is terminated when the score drops by more than X below the maximal score previously seen. </plain></SENT>
<SENT sid="210" pm="."><plain>Thus, the difference in the calculation order for filling the cells in the DP matrix may shift the terminated cells when X-dropoff is used. </plain></SENT>
<SENT sid="211" pm="."><plain>Nonetheless, the alignments are not changed when they have a high score. </plain></SENT>
<SENT sid="212" pm="."><plain>This is because the alignment paths rarely pass though the cell near a terminated one. </plain></SENT>
<SENT sid="213" pm="."><plain>Therefore, we believe that the search results are influenced by this optimization only slightly. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g006" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g006</object-id><label>Fig 6</label><caption><title><text><SENT sid="214" pm="."><plain>Examples of gapped extension on a GPU. </plain></SENT>
</text></title><p><text><SENT sid="215" pm="."><plain>A) An example of accesses for sequence data in GHOSTZ. </plain></SENT>
<SENT sid="216" pm="."><plain>B) An example of gapped extension with the short loop. </plain></SENT>
</text></p></caption><graphic xlink:href="pone.0157338.g006"/></fig></SecTag><p><text><SENT sid="217" pm="."><plain>Moreover, it is important to decrease branch divergence to reduce the computation time of gapped extension. </plain></SENT>
<SENT sid="218" pm="."><plain>Several threads in a block in the GPU execute the same instruction at any given moment, leading to branch divergence. </plain></SENT>
<SENT sid="219" pm="."><plain>For instance, when some threads in a block run an “if” statement, threads split in two for the branch, and the GPU causes all paths to be executed sequentially, even though each thread executes only one of the paths. </plain></SENT>
<SENT sid="220" pm="."><plain>On the other hand, when the threads run a “while” statement, the threads wait for execution of another thread to end. </plain></SENT>
<SENT sid="221" pm="."><plain>Branch divergence causes an increase in computation time and the number of inactive GPU threads. </plain></SENT>
<SENT sid="222" pm="."><plain>Therefore, there is a need to reduce branch divergence. </plain></SENT>
<SENT sid="223" pm="."><plain>We used the DP matrix to calculate the score of gapped extension, and the primary cause of the problem was the difference in size of the DP matrix among gapped extensions. </plain></SENT>
<SENT sid="224" pm="."><plain>The order of calculations for cells in GHOSTZ-GPU gapped extension is shown in Fig 6B. </plain></SENT>
<SENT sid="225" pm="."><plain>The loop for query length is an inner one during gapped extension. </plain></SENT>
<SENT sid="226" pm="."><plain>Therefore, the query length has a greater influence on branch divergence than the database sequence length does. </plain></SENT>
<SENT sid="227" pm="."><plain>For better load balancing, GHOSTZ-GPU sorts seeds by query length and then assigns a seed to a GPU thread successively. </plain></SENT>
<SENT sid="228" pm="."><plain>With this approach, the lengths of inner loops in gapped extensions are sorted in GHOSTZ-GPU.xtensions are sorted in GHOSTZ-GPU. </plain></SENT>
</text></p></sec><sec id="sec008"><title><text><SENT sid="229" pm="."><plain>Asynchronous Execution on a CPU and GPU </plain></SENT>
</text></title><p><text><SENT sid="230" pm="."><plain>To make full use of a computing environment with GPUs, an overlap between CPU and GPU calculations is necessary. </plain></SENT>
<SENT sid="231" pm="."><plain>GHOSTZ-GPU divides a process with a CPU and GPU into 2 main phases. </plain></SENT>
<SENT sid="232" pm="."><plain>The first phase consists of a seed search and similarity filtering. </plain></SENT>
<SENT sid="233" pm="."><plain>The second phase consists of chain filtering and gapped extension. </plain></SENT>
<SENT sid="234" pm="."><plain>CPU threads calculate data independently in each phase. </plain></SENT>
<SENT sid="235" pm="."><plain>To create an overlap between CPU and GPU calculations, the double-buffering technique is used for CPU and GPU types of memory. </plain></SENT>
<SENT sid="236" pm="."><plain>Two buffers are used as input and output to store results of the GPU calculations. </plain></SENT>
<SENT sid="237" pm="."><plain>Because of this method, the waiting time for synchronization of the CPU and GPU is reduced. </plain></SENT>
<SENT sid="238" pm="."><plain>Moreover, the computation time of memory copying between a CPU and GPU is hidden by the CPU and GPU calculations. </plain></SENT>
</text></p><p><text><SENT sid="239" pm="."><plain>The first phase is shown in Fig 7. </plain></SENT>
<SENT sid="240" pm="."><plain>GHOSTZ uses 3 tables, Be, Br, and Bm for a seed search. Be is a hash table for the representatives of clusters where the cluster contains only 1 member. Br is a hash table for a representative of a cluster (not stored in Be). Bm is a table for members of clusters. </plain></SENT>
<SENT sid="241" pm="."><plain>As shown in Fig 7, a seed search is performed against Br for distance calculation. </plain></SENT>
<SENT sid="242" pm="."><plain>Then, distances for similarity filtering are calculated on the GPU. </plain></SENT>
<SENT sid="243" pm="."><plain>The seed search against hash table is performed on the CPU simultaneously with this GPU calculation because this seed search is independent of similarity filtering. </plain></SENT>
<SENT sid="244" pm="."><plain>If the distance calculation is finished on the GPU, ungapped-extension calculation on the GPU is initiated. </plain></SENT>
<SENT sid="245" pm="."><plain>Once the seed search against Be on the CPU is completed, the seed search and similarity filtering for hash tables Br and Bm are performed on the CPU. </plain></SENT>
<SENT sid="246" pm="."><plain>After that, seeds from tables Br and Bm are built, and ungapped extension for these seeds is performed. </plain></SENT>
<SENT sid="247" pm="."><plain>This phase is continued until the process for all subsequences of queries is completed. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g007" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g007</object-id><label>Fig 7</label><caption><title><text><SENT sid="248" pm="."><plain>The workflow of the first phase in GHOSTZ-GPU. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g007"/></fig></SecTag><p><text><SENT sid="249" pm="."><plain>The second phase is shown in Fig 8. </plain></SENT>
<SENT sid="250" pm="."><plain>Chain filtering is performed on the CPU. </plain></SENT>
<SENT sid="251" pm="."><plain>If the memory is full, then seeds are sorted by query length for alignment, and then gapped extension is performed using these seeds. </plain></SENT>
<SENT sid="252" pm="."><plain>This phase continues until the process for all seeds is completed. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g008" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g008</object-id><label>Fig 8</label><caption><title><text><SENT sid="253" pm="."><plain>The workflow of the second phase of GHOSTZ-GPU. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g008"/></fig></SecTag><p><text><SENT sid="254" pm="."><plain>If multiple GPUs are used, then they are individually used by CPU threads. </plain></SENT>
<SENT sid="255" pm="."><plain>Each GPU is assigned to almost the same number of CPU threads. </plain></SENT>
<SENT sid="256" pm="."><plain>Each CPU thread has different global memory in the GPU. </plain></SENT>
<SENT sid="257" pm="."><plain>Because GPUs do not require communication among one another with this approach, GHOSTZ-GPU utilizes multiple GPUs effectively. </plain></SENT>
</text></p></sec><sec id="sec009"><title><text><SENT sid="258" pm="."><plain>Optimization of Loading a Database </plain></SENT>
</text></title><p><text><SENT sid="259" pm="."><plain>Loading a database, including indexes, represents a larger fraction of the computation time in GHOSTZ-GPU than in GHOSTZ because a sequence homology search is faster with a GPU calculation. </plain></SENT>
<SENT sid="260" pm="."><plain>GHOSTZ-GPU uses a special CPU thread to hide the latency of loading the database from threads for a sequence homology search. </plain></SENT>
<SENT sid="261" pm="."><plain>In GHOSTZ and GHOSTZ-GPU, a database is divided into several chunks to reduce working memory. </plain></SENT>
<SENT sid="262" pm="."><plain>The default chunk size is 1 GB. </plain></SENT>
<SENT sid="263" pm="."><plain>These tools sequentially search each database chunk and merge its results with the results of previous chunk searches. </plain></SENT>
<SENT sid="264" pm="."><plain>In GHOSTZ-GPU, the chunks are loaded sequentially by a special thread. Fig 9 shows the workflow with this thread. </plain></SENT>
<SENT sid="265" pm="."><plain>While the other threads perform the sequence homology searches against a database chunk, this thread loads the next database chunk. </plain></SENT>
<SENT sid="266" pm="."><plain>Due to this approach, the computation time of loading the database is hidden during the sequence homology search. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g009" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g009</object-id><label>Fig 9</label><caption><title><text><SENT sid="267" pm="."><plain>The workflow for loading of a database thread. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g009"/></fig></SecTag></sec></sec></SecTag><SecTag type="RESULTS"><sec sec-type="results" id="sec010"><title><text><SENT sid="268" pm="."><plain>Results </plain></SENT>
</text></title><sec id="sec011"><title><text><SENT sid="269" pm="."><plain>Datasets and Computing Environment </plain></SENT>
</text></title><p><text><SENT sid="270" pm="."><plain>We used the same dataset as Suzuki et al.[13] did for evaluation. </plain></SENT>
<SENT sid="271" pm="."><plain>We used amino acid sequences from the KEGG GENES database (as of May 2013). </plain></SENT>
<SENT sid="272" pm="."><plain>This database contains approximately 10 million protein sequences, which comprise a total of approximately 3.6 billion residues. </plain></SENT>
<SENT sid="273" pm="."><plain>For the query sequences, we used 3 datasets: metagenomic sequences of a soil microbiome (accession number SRR407548, read length 150 bp), metagenomic sequences of a human microbiome (accession number SRS011098, read length 101 bp), and metagenomic sequences of a marine microbiome (accession number ERR315856, read length 104 bp). </plain></SENT>
<SENT sid="274" pm="."><plain>SRR407548 and ERR315856 were obtained from the DNA Data Bank of Japan (DDBJ) Sequence Read Archive. </plain></SENT>
<SENT sid="275" pm="."><plain>SRS011098 was obtained from the web site of the Data Analysis and Coordination Center for the Human Microbiome Project (<ext-link ext-link-type="uri" xlink:href="http://www.hmpdacc.org/">http://www.hmpdacc.org/</ext-link>). </plain></SENT>
<SENT sid="276" pm="."><plain>We used the whole metagenomic shotgun sequencing data from dataset SRS011098. </plain></SENT>
<SENT sid="277" pm="."><plain>To evaluate the computation time, 1,000,000 randomly selected short DNA reads were used for all datasets. </plain></SENT>
<SENT sid="278" pm="."><plain>Each experiment was repeated 5 times, but we used only 10,000 randomly selected short DNA reads and used each tool once to evaluate the search sensitivity levels because of the computational costs. </plain></SENT>
<SENT sid="279" pm="."><plain>All the calculations were conducted on the TSUBAME 2.5 supercomputing system, Tokyo Institute of Technology, Japan. </plain></SENT>
<SENT sid="280" pm="."><plain>We used this node in all experiments, which consists of two 2.93-GHz Intel Xeon 5670 processors (6 cores), 54-GB memory, 3 NVIDIA Tesla K20Xes, and SUSE Linux Enterprise Server 11 Service Pack 3. </plain></SENT>
</text></p><p><text><SENT sid="281" pm="."><plain>The parameters of GHOSTZ and GHOSTZ-GPU were set to default values. </plain></SENT>
<SENT sid="282" pm="."><plain>To execute GHOSTZ and GHOSTZ-GPU, similar sequences were arranged close to each other in the database file based on the results of CD-HIT [28] before construction of database indexes. </plain></SENT>
</text></p></sec><sec id="sec012"><title><text><SENT sid="283" pm="."><plain>Evaluation of the Acceleration by GPUs </plain></SENT>
</text></title><p><text><SENT sid="284" pm="."><plain>To evaluate acceleration by GPUs and the relation between the number of GPUs and the acceleration, we ran GHOSTZ-GPU and GHOSTZ with their default options, except for the multithreading option. </plain></SENT>
<SENT sid="285" pm="."><plain>We used 1,000,000 randomly selected short DNA reads from dataset SRR407548 as queries in this evaluation. Fig 10 shows the averages and standard deviations of the computation time for each program with 1, 2, 4, 8, or 12 CPU threads and 1, 2, or 3 GPUs. </plain></SENT>
<SENT sid="286" pm="."><plain>According to the figure, GHOSTZ and GHOSTZ-GPU with 12 CPU threads show the best performance. </plain></SENT>
<SENT sid="287" pm="."><plain>In addition, GHOSTZ-GPU showed acceleration of approximately 4.1, 6.2, and 7.7-fold when we used 12 CPU threads with 1, 2, or 3 GPUs, respectively, as compared to GHOSTZ with 12 CPU threads. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g010" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g010</object-id><label>Fig 10</label><caption><title><text><SENT sid="288" pm="."><plain>Computation time with multithreading of a CPU and multiple GPUs. </plain></SENT>
</text></title></caption><graphic xlink:href="pone.0157338.g010"/></fig></SecTag></sec><sec id="sec013"><title><text><SENT sid="289" pm="."><plain>Evaluation of the Acceleration of Each Component by a GPU </plain></SENT>
</text></title><p><text><SENT sid="290" pm="."><plain>For this purpose, we ran GHOSTZ-GPU and GHOSTZ with their default options. </plain></SENT>
<SENT sid="291" pm="."><plain>We used the same dataset as in Table 1. Table 2 shows the averages and standard deviations of computation time for each step of GHOSTZ with 1 CPU thread and GHOSTZ-GPU with 1 CPU thread and 1 GPU. </plain></SENT>
<SENT sid="292" pm="."><plain>With a GPU, we found that distance calculation, ungapped extension, and gapped extension in GHOSTZ-GPU were accelerated by the factor of 28.7, 33.3, or 36.6, respectively, relative to GHOSTZ. </plain></SENT>
</text></p><SecTag type="TABLE"><table-wrap id="pone.0157338.t002" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.t002</object-id><label>Table 2</label><caption><title><text><SENT sid="293" pm="."><plain>Averages and standard deviations of computation time for each step of GHOSTZ-GPU and GHOSTZ calculations. </plain></SENT>
</text></title></caption><alternatives><graphic id="pone.0157338.t002g" xlink:href="pone.0157338.t002"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1"><text><SENT sid="294" pm="."><plain>GHOSTZ (sec.) </plain></SENT>
</text></th><th align="left" rowspan="1" colspan="1"><text><SENT sid="295" pm="."><plain>GHOSTZ-GPU (sec.) </plain></SENT>
</text></th><th align="left" rowspan="1" colspan="1"><text><SENT sid="296" pm="."><plain>Acceleration Ratio </plain></SENT>
</text></th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="297" pm="."><plain>Distance calculation </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="298" pm="."><plain>1340.7 ± 45.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="299" pm="."><plain>46.8 ± 0.1 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="300" pm="."><plain>28.7 ± 1.0 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="301" pm="."><plain>Ungapped Extension </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="302" pm="."><plain>18554.8 ± 695.8 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="303" pm="."><plain>557.5 ± 4.6 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="304" pm="."><plain>33.3 ± 1.4 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="305" pm="."><plain>Gapped Extension </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="306" pm="."><plain>17191.5 ± 672.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="307" pm="."><plain>469.1 ± 0.4 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="308" pm="."><plain>36.6 ± 1.4 </plain></SENT>
</text></td></tr></tbody></table></alternatives><table-wrap-foot><fn id="t002fn001"><p><text><SENT sid="309" pm="."><plain>This profile was obtained from the calculation involving short DNA reads in metagenomic sequences of the soil microbiome (SRR407548) as queries and KEGG GENES as a database. </plain></SENT>
<SENT sid="310" pm="."><plain>To obtain a profile for GHOSTZ, the functions of distance calculation, ungapped extension, and gapped extension were not in-lined. </plain></SENT>
<SENT sid="311" pm="."><plain>To obtain a profile for GHOSTZ-GPU, the computation time of memory copy between CPU and GPU was excluded. </plain></SENT>
<SENT sid="312" pm="."><plain>This is because this process is hidden by CPU and GPU calculations during asynchronous execution on a CPU and GPU. </plain></SENT>
</text></p></fn></table-wrap-foot></table-wrap></SecTag></sec><sec id="sec014"><title><text><SENT sid="313" pm="."><plain>Evaluation of Search Sensitivity </plain></SENT>
</text></title><p><text><SENT sid="314" pm="."><plain>To evaluate the search sensitivity of GHOSTZ-GPU, we ran GHOSTZ-GPU, GHOSTZ, RAPSearch (version 2.12), and DIAMOND (version 0.7.9). </plain></SENT>
<SENT sid="315" pm="."><plain>The sensitivity of the homology search for the different query sequences was estimated using the search results obtained by the Smith-Waterman local alignment algorithm implemented in SSEARCH [24] as the correct results. </plain></SENT>
<SENT sid="316" pm="."><plain>Because the Smith-Waterman algorithm is based on the dynamic programming algorithm and does not use any heuristics, it returns an optimal local alignment. </plain></SENT>
<SENT sid="317" pm="."><plain>The performance was estimated in terms of the fraction of the results that corresponded to the correct result. </plain></SENT>
<SENT sid="318" pm="."><plain>A search result was considered correct when the subject sequence with the highest score in SSEARCH was the same as the subject sequence obtained by each tool. </plain></SENT>
<SENT sid="319" pm="."><plain>We used only 10,000 randomly selected short DNA reads from SRR407548, SRS011098, and ERR315856 as queries and used each tool once during this evaluation for comparison with the results of SSEARCH. </plain></SENT>
<SENT sid="320" pm="."><plain>This is because the latter requires a lengthy computational time for large query datasets. </plain></SENT>
<SENT sid="321" pm="."><plain>To evaluate the software, we executed the RAPSearch program with 2 cases. </plain></SENT>
<SENT sid="322" pm="."><plain>One involved the default options, and the other involved command line options “-a T”, which instructed the program to perform a fast search [we called it RAPSearch (fast)]. </plain></SENT>
<SENT sid="323" pm="."><plain>We executed the DIAMOND program with 2 cases. </plain></SENT>
<SENT sid="324" pm="."><plain>One involved the “-c 1” [we called it DIAMOND (fast)], and the other involved command line options “-c 1 --sensitive” [we called it DIAMOND (sensitive)]. “-c” instructed the program to change the number of chunks for processing the seed index. “--sensitive” instructed the program to perform a sensitive search. </plain></SENT>
</text></p><p><text><SENT sid="325" pm="."><plain>The results for SRR407548, SRS011098, and ERR315856 are shown in Figs 11, 12 and 13. </plain></SENT>
<SENT sid="326" pm="."><plain>These figures indicate that the search sensitivity of GHOSTZ-GPU was almost equal to that of GHOSTZ. </plain></SENT>
<SENT sid="327" pm="."><plain>Because it is difficult to compare many plots involving the results obtained with different parameters, we used single-value search sensitivity, which is calculated as the ratio of correct queries to all queries whose E-values &lt;1.0 × E−5 because the hits that have a high E-value are unreliable and not used in practice. </plain></SENT>
<SENT sid="328" pm="."><plain>For instance, Trunbaugh et al. used hits with E values less than 1.0 × E−5[8], and Kurokawa et al. used hits with E values less than 1.0 × E−8[9]. Table 3 shows search sensitivity for each program. </plain></SENT>
<SENT sid="329" pm="."><plain>The search sensitivity of GHOSTZ-GPU for SRR407548 was almost equal to that of GHOSTZ, RAPSearch, and DIAMOND (sensitive) and higher than that of RAPSearch (fast) and DIAMOND (fast). </plain></SENT>
<SENT sid="330" pm="."><plain>The search sensitivity values of GHOSTZ-GPU for SRS011098 and ERR315856 were almost equal to those of GHOSTZ and RAPSearch and higher than those of RAPSearch (fast), DIAMOND (fast), and DIAMOND (sensitive). </plain></SENT>
</text></p><SecTag type="FIG"><fig id="pone.0157338.g011" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g011</object-id><label>Fig 11</label><caption><title><text><SENT sid="331" pm="."><plain>Search sensitivity of different search methods. </plain></SENT>
</text></title><p><text><SENT sid="332" pm="."><plain>Searches of SRR407548 sequences against the KEGG GENES database. </plain></SENT>
</text></p></caption><graphic xlink:href="pone.0157338.g011"/></fig></SecTag><SecTag type="FIG"><fig id="pone.0157338.g012" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g012</object-id><label>Fig 12</label><caption><title><text><SENT sid="333" pm="."><plain>Search sensitivity of different search methods. </plain></SENT>
</text></title><p><text><SENT sid="334" pm="."><plain>Searches of SRS011098 sequences against the KEGG GENES database. </plain></SENT>
</text></p></caption><graphic xlink:href="pone.0157338.g012"/></fig></SecTag><SecTag type="FIG"><fig id="pone.0157338.g013" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.g013</object-id><label>Fig 13</label><caption><title><text><SENT sid="335" pm="."><plain>Search sensitivity of different search methods. </plain></SENT>
</text></title><p><text><SENT sid="336" pm="."><plain>Searches of ERR315856 sequences against the KEGG GENES database. </plain></SENT>
</text></p></caption><graphic xlink:href="pone.0157338.g013"/></fig></SecTag><SecTag type="TABLE"><table-wrap id="pone.0157338.t003" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.t003</object-id><label>Table 3</label><caption><title><text><SENT sid="337" pm="."><plain>Search sensitivity for SRR407548, SRS011098, and ERR315856. </plain></SENT>
</text></title></caption><alternatives><graphic id="pone.0157338.t003g" xlink:href="pone.0157338.t003"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1"><text><SENT sid="338" pm="."><plain>SRR407548 </plain></SENT>
</text></th><th align="left" rowspan="1" colspan="1"><text><SENT sid="339" pm="."><plain>SRS011098 </plain></SENT>
</text></th><th align="left" rowspan="1" colspan="1"><text><SENT sid="340" pm="."><plain>ERR315856 </plain></SENT>
</text></th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="341" pm="."><plain>GHOSTZ-GPU </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="342" pm="."><plain>0.86 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="343" pm="."><plain>0.98 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="344" pm="."><plain>0.97 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="345" pm="."><plain>GHOSTZ </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="346" pm="."><plain>0.86 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="347" pm="."><plain>0.98 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="348" pm="."><plain>0.97 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="349" pm="."><plain>RAPSearch </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="350" pm="."><plain>0.89 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="351" pm="."><plain>0.98 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="352" pm="."><plain>0.97 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="353" pm="."><plain>RAPSearch (fast) </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="354" pm="."><plain>0.62 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="355" pm="."><plain>0.93 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="356" pm="."><plain>0.88 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="357" pm="."><plain>DIAMOND (fast) </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="358" pm="."><plain>0.72 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="359" pm="."><plain>0.78 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="360" pm="."><plain>0.90 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="361" pm="."><plain>DIAMOND (sensitive) </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="362" pm="."><plain>0.88 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="363" pm="."><plain>0.79 </plain></SENT>
</text></td><td align="char" char="." rowspan="1" colspan="1"><text><SENT sid="364" pm="."><plain>0.93 </plain></SENT>
</text></td></tr></tbody></table></alternatives><table-wrap-foot><fn id="t003fn001"><p><text><SENT sid="365" pm="."><plain>The search sensitivity is calculated as the ratio of correct queries with the E-values &lt; 105. </plain></SENT>
</text></p></fn></table-wrap-foot></table-wrap></SecTag><p><text><SENT sid="366" pm="."><plain>Moreover, we compared the subject sequences that had the highest score in the results of GHOSTZ-GPU with those of GHOSTZ. </plain></SENT>
<SENT sid="367" pm="."><plain>The results of GHOSTZ-GPU were different from those of GHOSTZ. </plain></SENT>
<SENT sid="368" pm="."><plain>This difference is caused by the difference in the calculation order for filling the cells in the DP matrix during gapped extension. </plain></SENT>
<SENT sid="369" pm="."><plain>However, the difference between them is only 2–4 queries. </plain></SENT>
<SENT sid="370" pm="."><plain>Therefore, we believe that GHOSTZ-GPU has sufficient search sensitivity for most of metagenomic applications. </plain></SENT>
</text></p></sec><sec id="sec015"><title><text><SENT sid="371" pm="."><plain>Evaluation of Computation Time </plain></SENT>
</text></title><p><text><SENT sid="372" pm="."><plain>To further evaluate GHOSTZ-GPU, we compared its computation time with that of GHOSTZ, RAPSearch, and DIAMOND. </plain></SENT>
<SENT sid="373" pm="."><plain>Optimization of loading the database is also effective for GHOSTZ; therefore, we applied this optimization to GHOSTZ. </plain></SENT>
<SENT sid="374" pm="."><plain>We evaluated these tools using 1,000,000 randomly selected short DNA reads from datasets SRR407548, SRS011098, and ERR315856 and from the KEGG GENES database. </plain></SENT>
<SENT sid="375" pm="."><plain>These software packages were used with the same commands that were used to analyze search sensitivity. </plain></SENT>
</text></p><p><text><SENT sid="376" pm="."><plain>The averages and standard deviations of computation time of the tested methods for SRR407548, SRS011098, and ERR315856 are shown in Table 4. </plain></SENT>
<SENT sid="377" pm="."><plain>GHOSTZ-GPU with 1 GPU was approximately 3.0–4.1, 3.1–3.9, 12.1–19.0, and 0.9–2.0 times faster than GHOSTZ (original), GHOSTZ (+ loading database thread), RAPSearch, and DIAMOND (sensitive) with 12 CPU threads, respectively. </plain></SENT>
<SENT sid="378" pm="."><plain>Moreover, GHOSTZ-GPU with 3 GPUs was approximately 5.8–7.7, 6.0–7.4, 21.6–35.9, and 1.6–3.8 times faster than GHOSTZ (original), GHOSTZ (+ loading database thread), RAPSearch, and DIAMOND (sensitive) with 12 CPU threads, respectively. </plain></SENT>
<SENT sid="379" pm="."><plain>GHOSTZ-GPU with 3 GPUs was slower than RAPSearch (fast) with 12 CPU threads on ERR315856 and slower than DIAMOND (fast) with 12 CPU threads on all the data. </plain></SENT>
<SENT sid="380" pm="."><plain>Nevertheless, the sensitivity of RAPSearch (fast) and DIAMOND (fast) was clearly worse than that of GHOSTZ-GPU. </plain></SENT>
<SENT sid="381" pm="."><plain>Thus, GHOSTZ-GPU shows the best performance when high sensitivity is required. </plain></SENT>
</text></p><SecTag type="TABLE"><table-wrap id="pone.0157338.t004" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.t004</object-id><label>Table 4</label><caption><title><text><SENT sid="382" pm="."><plain>Averages and standard deviations of computation time for datasets SRR407548, SRS011098, and ERR315856. </plain></SENT>
</text></title></caption><alternatives><graphic id="pone.0157338.t004g" xlink:href="pone.0157338.t004"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1"><text><SENT sid="383" pm="."><plain>SRR407548 (sec.) </plain></SENT>
</text></th><th align="left" rowspan="1" colspan="1"><text><SENT sid="384" pm="."><plain>SRS011098 (sec.) </plain></SENT>
</text></th><th align="left" rowspan="1" colspan="1"><text><SENT sid="385" pm="."><plain>ERR315856 (sec.) </plain></SENT>
</text></th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="386" pm="."><plain>GHOSTZ-GPU (1 GPU) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="387" pm="."><plain>1038.2 ± 47.4 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="388" pm="."><plain>730.8 ± 35.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="389" pm="."><plain>1025.3 ± 42.8 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="390" pm="."><plain>GHOSTZ-GPU (2 GPUs) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="391" pm="."><plain>682.4 ± 56.6 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="392" pm="."><plain>500.9 ± 70.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="393" pm="."><plain>701.6 ± 56.6 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="394" pm="."><plain>GHOSTZ-GPU (3 GPUs) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="395" pm="."><plain>551.5 ± 34.4 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="396" pm="."><plain>375.2 ± 10.2 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="397" pm="."><plain>574.8 ± 17.6 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="398" pm="."><plain>GHOSTZ (+ loading database thread) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="399" pm="."><plain>4051.6 ± 110.5 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="400" pm="."><plain>2249.8 ± 34.1 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="401" pm="."><plain>3533.8 ± 96.0 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="402" pm="."><plain>GHOSTZ (original) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="403" pm="."><plain>4231.8 ± 159.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="404" pm="."><plain>2178.3 ± 11.0 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="405" pm="."><plain>3560.2 ± 52.1 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="406" pm="."><plain>RAPSearch </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="407" pm="."><plain>19781.2 ± 2349.6 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="408" pm="."><plain>9075.8 ± 101.4 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="409" pm="."><plain>12379.2 ± 192.9 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="410" pm="."><plain>RAPSearch (fast) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="411" pm="."><plain>996.4 ± 13.2 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="412" pm="."><plain>654.8 ± 5.9 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="413" pm="."><plain>993.1 ± 31.6 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="414" pm="."><plain>DIAMOND (fast) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="415" pm="."><plain>479.3 ± 55.2 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="416" pm="."><plain>275.6 ± 74.8 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="417" pm="."><plain>279.0 ± 6.7 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="418" pm="."><plain>DIAMOND (sensitive) </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="419" pm="."><plain>2071.7 ± 4.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="420" pm="."><plain>713.6 ± 1.9 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="421" pm="."><plain>931.5 ± 18.0 </plain></SENT>
</text></td></tr></tbody></table></alternatives><table-wrap-foot><fn id="t004fn001"><p><text><SENT sid="422" pm="."><plain>We assessed each tool with 12 CPU threads. </plain></SENT>
</text></p></fn></table-wrap-foot></table-wrap></SecTag></sec><sec id="sec016"><title><text><SENT sid="423" pm="."><plain>Evaluation of Optimizations for GPU calculations </plain></SENT>
</text></title><p><text><SENT sid="424" pm="."><plain>To further evaluate GHOSTZ-GPU, we evaluated key optimizations: asynchronous execution on a CPU and GPU, addition of a thread to loading of a database, group memory access, and load balancing of gapped extension. </plain></SENT>
<SENT sid="425" pm="."><plain>We performed GHOSTZ with 12 CPU threads and GHOSTZ-GPU with 12 CPU threads and 3 GPUs. </plain></SENT>
<SENT sid="426" pm="."><plain>We ran GHOSTZ-GPU with and without each optimization. </plain></SENT>
<SENT sid="427" pm="."><plain>We used 1,000,000 randomly selected short DNA reads from SRR407548 against the KEGG GENES database. </plain></SENT>
<SENT sid="428" pm="."><plain>The acceleration ratios with these optimizations relative to GHOSTZ without the thread for loading a database are shown in Table 5. </plain></SENT>
<SENT sid="429" pm="."><plain>Each optimization was found to accelerate GHOSTZ-GPU. </plain></SENT>
<SENT sid="430" pm="."><plain>Asynchronous execution on a CPU and GPU and addition of a thread to the loading of a database yielded the greatest increase in computation speed. </plain></SENT>
<SENT sid="431" pm="."><plain>Therefore, these optimizations are important for accelerating a search for protein sequence homology using a GPU. </plain></SENT>
</text></p><SecTag type="TABLE"><table-wrap id="pone.0157338.t005" orientation="portrait" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0157338.t005</object-id><label>Table 5</label><caption><title><text><SENT sid="432" pm="."><plain>Averages and standard deviations of computation time and acceleration ratio for each optimization of GHOSTZ-GPU. </plain></SENT>
</text></title></caption><alternatives><graphic id="pone.0157338.t005g" xlink:href="pone.0157338.t005"/><table frame="box" rules="all" border="0"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" rowspan="1" colspan="1"/><th align="center" rowspan="1" colspan="1"><text><SENT sid="433" pm="."><plain>Computation time (sec.) </plain></SENT>
</text></th><th align="center" rowspan="1" colspan="1"><text><SENT sid="434" pm="."><plain>Acceleration ratio of each optimization </plain></SENT>
</text></th><th align="center" rowspan="1" colspan="1"><text><SENT sid="435" pm="."><plain>Cumulative acceleration ratio </plain></SENT>
</text></th></tr></thead><tbody><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="436" pm="."><plain>GHOSTZ </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="437" pm="."><plain>4051.6 ± 110.5 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="438" pm="."><plain>1.0 ± 0.0 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="439" pm="."><plain>1.0 ± 0.0 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="440" pm="."><plain>+ GPU </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="441" pm="."><plain>993.9 ± 21.5 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="442" pm="."><plain>4.1 ± 0.2 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="443" pm="."><plain>4.1 ± 0.2 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="444" pm="."><plain>+ Asynchronous execution </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="445" pm="."><plain>705.9 ± 38.7 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="446" pm="."><plain>1.4 ± 0.1 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="447" pm="."><plain>5.8 ± 0.4 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="448" pm="."><plain>+ Loading database </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="449" pm="."><plain>655.7 ± 11.9 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="450" pm="."><plain>1.1 ± 0.1 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="451" pm="."><plain>6.2 ± 0.2 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="452" pm="."><plain>+ Group memory access </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="453" pm="."><plain>618.7 ± 45.0 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="454" pm="."><plain>1.1 ± 0.1 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="455" pm="."><plain>6.6 ± 0.5 </plain></SENT>
</text></td></tr><tr><td align="left" rowspan="1" colspan="1"><text><SENT sid="456" pm="."><plain>+ Load balancing </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="457" pm="."><plain>551.5 ± 34.4 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="458" pm="."><plain>1.1 ± 0.1 </plain></SENT>
</text></td><td align="left" rowspan="1" colspan="1"><text><SENT sid="459" pm="."><plain>7.4 ± 0.4 </plain></SENT>
</text></td></tr></tbody></table></alternatives><table-wrap-foot><fn id="t005fn001"><p><text><SENT sid="460" pm="."><plain>We performed GHOSTZ-GPU with and without optimizations. </plain></SENT>
<SENT sid="461" pm="."><plain>The acceleration in processing speed is shown as the ratio of the time used for GHOSTZ-GPU with an optimization relative to the time used for GHOSTZ-GPU with previous optimization and GHOSTZ. </plain></SENT>
</text></p></fn></table-wrap-foot></table-wrap></SecTag></sec></sec></SecTag><SecTag type="DISCUSS"><sec sec-type="conclusions" id="sec017"><title><text><SENT sid="462" pm="."><plain>Discussion </plain></SENT>
</text></title><p><text><SENT sid="463" pm="."><plain>In this study, we mapped distance calculation, ungapped extension, and gapped extension of GHOSTZ onto a GPU. </plain></SENT>
<SENT sid="464" pm="."><plain>GHOSTZ-GPU with 2 GPUs is approximately 6 times faster than GHOSTZ with 2 CPU sockets. </plain></SENT>
<SENT sid="465" pm="."><plain>The accelerated GPU-BLAST and CUDA-BLASTP with 1 GPU are estimated to be equivalent to twice NCBI-BLAST with a single CPU socket or less [26, 27]. </plain></SENT>
<SENT sid="466" pm="."><plain>Therefore, GHOSTZ-GPU showed a greater increase in speed than GPU-based BLAST tools. </plain></SENT>
<SENT sid="467" pm="."><plain>One of the reasons for acceleration of calculations with GPUs is the use of seed search in GHOSTZ. </plain></SENT>
<SENT sid="468" pm="."><plain>BLAST searches consist of 3 main steps: a seed search, ungapped extension, and gapped extension; the bottleneck in BLAST is the seed search. </plain></SENT>
<SENT sid="469" pm="."><plain>Therefore, the seed search is mapped onto a GPU in these tools. </plain></SENT>
<SENT sid="470" pm="."><plain>On the other hand, a seed search in BLAST requires several random memory accesses. </plain></SENT>
<SENT sid="471" pm="."><plain>Random memory access decreases computing speed on a GPU. </plain></SENT>
<SENT sid="472" pm="."><plain>Accordingly, this step does not utilize sufficient computing resources of GPUs. </plain></SENT>
<SENT sid="473" pm="."><plain>A seed search by means of other tools also requires random memory access. </plain></SENT>
<SENT sid="474" pm="."><plain>In contrast, in GHOSTZ, a seed search does not take much computation time, and GHSOTZ is one of the fastest tools for searches for protein sequence homology. </plain></SENT>
<SENT sid="475" pm="."><plain>Thus, GHOSTZ-GPU showed a significant increase in speed. </plain></SENT>
<SENT sid="476" pm="."><plain>If we run a distance calculation, ungapped extension, and gapped extension in GHOSTZ on GPUs, the remaining steps become new bottlenecks. </plain></SENT>
<SENT sid="477" pm="."><plain>For a CPU calculation in GHOSTZ-GPU, the most time-consuming step is the seed search. </plain></SENT>
<SENT sid="478" pm="."><plain>Nonetheless, this step overlaps with distance calculation and ungapped extension on GPUs. </plain></SENT>
<SENT sid="479" pm="."><plain>Therefore, the true computation time of the seed search was hidden by that of distance calculation and of ungapped extension on GPUs. </plain></SENT>
<SENT sid="480" pm="."><plain>Nevertheless, the file I/O in a database accounts for a greater fraction of the computing time for GHOSTZ-GPU. </plain></SENT>
<SENT sid="481" pm="."><plain>Therefore, GHOSTZ-GPU should be executed with a large amount of queries concurrently to optimize the performance. </plain></SENT>
<SENT sid="482" pm="."><plain>On the other hand, a greater amount of memory is required than that for execution of a small number of queries. </plain></SENT>
<SENT sid="483" pm="."><plain>When we used 1,000,000 randomly selected short DNA reads from SRR407548 and the KEGG GENES database, GHOSTZ-GPU required approximately 50 GB of CPU memory for the homology search proper. </plain></SENT>
<SENT sid="484" pm="."><plain>Thus, the memory size of current typical computing systems may be insufficient for GHOSTZ-GPU. </plain></SENT>
<SENT sid="485" pm="."><plain>For instance, a node in Titan, which is a supercomputer at the Oak Ridge National Laboratory, has only 32 GB of memory. </plain></SENT>
<SENT sid="486" pm="."><plain>Therefore, big query data cannot be analyzed by GHOSTZ-GPU at once on this computing system. </plain></SENT>
<SENT sid="487" pm="."><plain>On the other hand, computer systems with larger memory, e.g., TSUBAME 2.5, are under development and the memory size is increasing. </plain></SENT>
<SENT sid="488" pm="."><plain>Therefore, GHOSTZ-GPU should soon be available in common computing environments. </plain></SENT>
</text></p><p><text><SENT sid="489" pm="."><plain>GHOSTZ-GPU is developed for homology search of metagenome short reads, but it would be more valuable if it can be used for general protein sequence homology search. </plain></SENT>
<SENT sid="490" pm="."><plain>To check the point, we compared the sensitivity of GHOSTZ-GPU, RAPSearch, DIAMOND to BLASTP mode of NCBI-BLAST (2.2.28+) using proteins sequences as queries. </plain></SENT>
<SENT sid="491" pm="."><plain>We employed a method used in a research by Boratyn et al. [20] to evaluate the performance of remote homologue detection of sequence homology search tools. </plain></SENT>
<SENT sid="492" pm="."><plain>We used ASTRAL40 subset (version 2.06) [29] of the Structural Classification of Proteins (SCOP) [30] database in this evaluation. S1 Fig shows the curves denoting the number of true positives vs. the number of false positives for each tool. </plain></SENT>
<SENT sid="493" pm="."><plain>The performances of all metagenome homology search tools, GHOSTZ-GPU, RAPSearch and DIAMOND, are clearly less than that of BLAST in general protein sequence homology search, while the tools are much faster than BLAST and has enough search sensitivity for metagenome short reads. </plain></SENT>
<SENT sid="494" pm="."><plain>The lower search sensitivity of those tools would mainly come from the longer seed length than BLAST. </plain></SENT>
<SENT sid="495" pm="."><plain>The results indicate that the search sensitivity of GHOSTZ-GPU is insufficient for remote homologue detection, and thus the use of GHOSTZ-GPU is limited in homology search of general protein sequences. </plain></SENT>
</text></p><p><text><SENT sid="496" pm="."><plain>In summary, we developed a GPU version of GHOSTZ, which is the fastest tool for searches for protein sequence homology. </plain></SENT>
<SENT sid="497" pm="."><plain>Several calculations, distance calculation, ungapped extension, and gapped extension, are bottlenecks in GHOSTZ. </plain></SENT>
<SENT sid="498" pm="."><plain>We mapped these processes onto GPUs and optimized memory access in the GPU calculation. </plain></SENT>
<SENT sid="499" pm="."><plain>GHOSTZ-GPU with 12 CPU threads and 1 GPU retains sufficient search sensitivity for practical analyses and is 3.0–4.1 times faster than GHOSTZ with 12 CPU threads. </plain></SENT>
<SENT sid="500" pm="."><plain>Moreover, GHOSTZ-GPU with 12 CPU threads and 3 GPUs maintains sufficient search sensitivity for practical analyses and is 5.8–7.7 times faster than GHOSTZ with 12 CPU threads. </plain></SENT>
<SENT sid="501" pm="."><plain>GHOSTZ-GPU on 12 CPU cores and 3 GPUs is estimated to achieve an 1073- to 2010-fold increase in processing speed relative to BLASTX on 12 CPU cores because GHOSTZ was estimated to be approximately 185- to 261-fold faster than BLASTX. </plain></SENT>
<SENT sid="502" pm="."><plain>If we use GHOSTZ-GPU to analyze the data produced by HiSeq2500 and stored in the KEGG GENES database and approximately 50–100 nodes on TSUBAME 2.5 in metagenomic analysis, the required time is estimated to be only 1 day. </plain></SENT>
<SENT sid="503" pm="."><plain>On the basis of these estimates, we could perform metagenomic analysis of all data produced by the latest DNA sequencer in real time. </plain></SENT>
<SENT sid="504" pm="."><plain>At present, the sequencing technology continues to be improved, and the size of sequence data is on the rise. </plain></SENT>
<SENT sid="505" pm="."><plain>GHOSTZ-GPU and computers with GPUs could be a suitable alternative. </plain></SENT>
</text></p></sec></SecTag><SecTag type="SUPPL"><sec sec-type="supplementary-material" id="sec018"><title><text><SENT sid="506" pm="."><plain>Supporting Information </plain></SENT>
</text></title><supplementary-material content-type="local-data" id="pone.0157338.s001"><label>S1 Fig</label><caption><title><text><SENT sid="507" pm="."><plain>Number of true positives vs number of false positives for different search methods on the ASTRAL. </plain></SENT>
</text></title><p><text><SENT sid="508" pm="."><plain>The query set was created by sorting the SCOP domains in a lexicographic order and selecting even numbered sequences without queries that are the sole member of the superfamily in ASTRAL 40. </plain></SENT>
<SENT sid="509" pm="."><plain>In the evaluation, self-hits were ignored. </plain></SENT>
<SENT sid="510" pm="."><plain>If a hit of a search belongs to the same SCOP superfamily of the query, it was considered as a true positive. </plain></SENT>
<SENT sid="511" pm="."><plain>And if a hit belongs to the different SCOP fold of the query, it was considered as a false positive. </plain></SENT>
<SENT sid="512" pm="."><plain>The gapped extension of GHOSTZ-GPU was performed on CPU because gapped extension of GHOSTZ-GPU is designed for short sequence and the size of GPU memory is insufficient for sequences in ASTRAL 40. </plain></SENT>
</text></p><p><text><SENT sid="513" pm="."><plain>(PDF) </plain></SENT>
</text></p></caption><media xlink:href="pone.0157338.s001.pdf"><caption><p><text><SENT sid="514" pm="."><plain>Click here for additional data file. </plain></SENT>
</text></p></caption></media></supplementary-material></sec></SecTag></body><back><SecTag type="ACK_FUND"><ack><p><text4fund><text><SENT sid="515" pm="."><plain>The authors thank Prof. </plain></SENT>
<SENT sid="516" pm="."><plain>Ken Kurokawa and Dr. Takuji Yamada for their helpful discussion on metagenomic analysis. </plain></SENT>
<SENT sid="517" pm="."><plain>The authors also thank Mr. </plain></SENT>
<SENT sid="518" pm="."><plain>Brent Oster, Mr. </plain></SENT>
<SENT sid="519" pm="."><plain>Marc Hamilton, Mr. </plain></SENT>
<SENT sid="520" pm="."><plain>Mark Berger, Mr. </plain></SENT>
<SENT sid="521" pm="."><plain>Nuno Subtil, Mr. </plain></SENT>
<SENT sid="522" pm="."><plain>Jonathan Cohen, and Mr. </plain></SENT>
<SENT sid="523" pm="."><plain>Jacopo Pantaleoni at NVIDIA Corporation for providing us with an excellent research environment, insightful comments, and suggestions for this study. </plain></SENT>
</text></text4fund></p></ack></SecTag><SecTag type="REF"><ref-list><title>References</title><ref id="pone.0157338.ref001"><text><SENT sid="524" pm="."><plain>1 KanehisaM, GotoS. KEGG: Kyoto Encyclopedia of Genes and Genomes. Nucleic Acids Research. 2000;28(1):27–30. 10.1093/nar/28.1.27 <?supplied-pmid 10592173?>10592173 </plain></SENT>
</text></ref><ref id="pone.0157338.ref002"><text><SENT sid="525" pm="."><plain>2 KanehisaM, GotoS, SatoY, FurumichiM, TanabeM. KEGG for integration and interpretation of large-scale molecular data sets. Nucleic Acids Research. 2012;40(D1):D109–D114. 10.1093/nar/gkr988 <?supplied-pmid 22080510?>22080510 </plain></SENT>
</text></ref><ref id="pone.0157338.ref003"><text><SENT sid="526" pm="."><plain>3 TatusovRL, KooninEV, LipmanDJ. A Genomic Perspective on Protein Families. Science. 1997;278(5338):631–637. 10.1126/science.278.5338.631 <?supplied-pmid 9381173?>9381173 </plain></SENT>
</text></ref><ref id="pone.0157338.ref004"><text><SENT sid="527" pm="."><plain>4 TatusovR, FedorovaN, JacksonJ, JacobsA, KiryutinB, KooninE, et al The COG database: an updated version includes eukaryotes. BMC Bioinformatics. 2003;4(1):41 10.1186/1471-2105-4-41 <?supplied-pmid 12969510?>12969510 </plain></SENT>
</text></ref><ref id="pone.0157338.ref005"><text><SENT sid="528" pm="."><plain>5 FinnRD, MistryJ, TateJ, CoggillP, HegerA, PollingtonJE, et al The Pfam protein families database. Nucleic Acids Research. 2010;38(suppl 1):D211–D222. 10.1093/nar/gkp985 <?supplied-pmid 19920124?>19920124 </plain></SENT>
</text></ref><ref id="pone.0157338.ref006"><text><SENT sid="529" pm="."><plain>6 AltschulSF, GishW, MillerW, MyersEW, LipmanDJ. Basic local alignment search tool. Journal of Molecular Biology. 1990;215(3):403–410. 10.1016/S0022-2836(05)80360-2 <?supplied-pmid 2231712?>2231712 </plain></SENT>
</text></ref><ref id="pone.0157338.ref007"><text><SENT sid="530" pm="."><plain>7 AltschulSF, MaddenTL, SchäfferAA, ZhangJ, ZhangZ, MillerW, et al Gapped BLAST and PSI-BLAST: a new generation of protein database search programs. Nucleic Acids Research. 1997;25(17):3389–3402. 10.1093/nar/25.17.3389 <?supplied-pmid 9254694?>9254694 </plain></SENT>
</text></ref><ref id="pone.0157338.ref008"><text><SENT sid="531" pm="."><plain>8 TurnbaughPJ, LeyRE, MahowaldMA, MagriniV, MardisER, GordonJI. An obesity-associated gut microbiome with increased capacity for energy harvest. Nature. 2006;444(7122):1027–131. 10.1038/nature05414 <?supplied-pmid 17183312?>17183312 </plain></SENT>
</text></ref><ref id="pone.0157338.ref009"><text><SENT sid="532" pm="."><plain>9 KurokawaK, ItohT, KuwaharaT, OshimaK, TohH, ToyodaA, et al Comparative Metagenomics Revealed Commonly Enriched Gene Sets in Human Gut Microbiomes. DNA Research. 2007;14(4):169–181. 10.1093/dnares/dsm018 <?supplied-pmid 17916580?>17916580 </plain></SENT>
</text></ref><ref id="pone.0157338.ref010"><text><SENT sid="533" pm="."><plain>10 YeY, ChoiJH, TangH. RAPSearch: a fast protein similarity search tool for short reads. BMC Bioinformatics. 2011;12(1):159 10.1186/1471-2105-12-159 <?supplied-pmid 21575167?>21575167 </plain></SENT>
</text></ref><ref id="pone.0157338.ref011"><text><SENT sid="534" pm="."><plain>11 ZhaoY, TangH, YeY. RAPSearch2: a fast and memory-efficient protein similarity search tool for next-generation sequencing data. Bioinformatics. 2012;28(1):125–126. 10.1093/bioinformatics/btr595 <?supplied-pmid 22039206?>22039206 </plain></SENT>
</text></ref><ref id="pone.0157338.ref012"><text><SENT sid="535" pm="."><plain>12 SuzukiS, KakutaM, IshidaT, AkiyamaY. GHOSTX: An Improved Sequence Homology Search Algorithm Using a Query Suffix Array and a Database Suffix Array. PLoS ONE. 2014;9(8):e103833 10.1371/journal.pone.0103833 <?supplied-pmid 25099887?>25099887 </plain></SENT>
</text></ref><ref id="pone.0157338.ref013"><text><SENT sid="536" pm="."><plain>13 SuzukiS, KakutaM, IshidaT, AkiyamaY. Faster sequence homology searches by clustering subsequences. Bioinformatics. 2015;31(8):1183–1190. 10.1093/bioinformatics/btu780 <?supplied-pmid 25432166?>25432166 </plain></SENT>
</text></ref><ref id="pone.0157338.ref014"><text><SENT sid="537" pm="."><plain>14 BuchfinkB, XieC, HusonDH. Fast and Sensitive Protein Alignment using DIAMOND. Nature Methods. 2015;12(1):59–60. 10.1038/nmeth.3176 <?supplied-pmid 25402007?>25402007 </plain></SENT>
</text></ref><ref id="pone.0157338.ref015"><text><SENT sid="538" pm="."><plain>15 LuoR, WongT, ZhuJ, LiuCM, ZhuX, WuE, et al SOAP3-dp: Fast, Accurate and Sensitive GPU-Based Short Read Aligner. PLoS ONE. 2013;8(5):e65632 10.1371/journal.pone.0065632 <?supplied-pmid 23741504?>23741504 </plain></SENT>
</text></ref><ref id="pone.0157338.ref016"><text><SENT sid="539" pm="."><plain>16Shimoda T, Ishida T, Suzuki S, Ohue M, Akiyama Y. MEGADOCK-GPU: Acceleration of Protein-Protein Docking Calculation on GPUs. </plain></SENT>
<SENT sid="541" pm="."><plain>In: Proceedings of the International Conference on Bioinformatics, Computational Biology and Biomedical Informatics. </plain></SENT>
<SENT sid="542" pm="."><plain>BCB’13. </plain></SENT>
<SENT sid="543" pm="."><plain>New York, NY, USA: ACM; 2013. p. 883:883–883:889. </plain></SENT>
<SENT sid="545" pm="."><plain>Available from: <ext-link ext-link-type="uri" xlink:href="http://doi.acm.org/10.1145/2506583.2506693">http://doi.acm.org/10.1145/2506583.2506693</ext-link> </plain></SENT>
</text></ref><ref id="pone.0157338.ref017"><text><SENT sid="546" pm="."><plain>17 GoudeyB, RawlinsonD, WangQ, ShiF, FerraH, CampbellR, et al GWIS—model-free, fast and exhaustive search for epistatic interactions in case-control GWAS. BMC Genomics. 2013;14(Suppl 3):S10 10.1186/1471-2164-14-S3-S10 <?supplied-pmid 23819779?>23819779 </plain></SENT>
</text></ref><ref id="pone.0157338.ref018"><text><SENT sid="547" pm="."><plain>18 SmithTF, WatermanMS. Identification of common molecular subsequences. Journal of Molecular Biology. 1981;147(1):195–197. 10.1016/0022-2836(81)90087-5 <?supplied-pmid 7265238?>7265238 </plain></SENT>
</text></ref><ref id="pone.0157338.ref019"><text><SENT sid="548" pm="."><plain>19 LiuY, WirawanA, SchmidtB. CUDASW++ 3.0: accelerating Smith-Waterman protein database search by coupling CPU and GPU SIMD instructions. BMC Bioinformatics. 2013;14(1):117 10.1186/1471-2105-14-117 <?supplied-pmid 23557111?>23557111 </plain></SENT>
</text></ref><ref id="pone.0157338.ref020"><text><SENT sid="549" pm="."><plain>20 KorparM, SosicM, BlazekaD, SikicM. SW#db: GPU-Accelerated Exact Sequence Similarity Database Search. PLoS ONE. 2016;10(12):1–11. </plain></SENT>
</text></ref><ref id="pone.0157338.ref021"><text><SENT sid="550" pm="."><plain>21 LiuY, HongY, LinCY, HungCL. Accelerating Smith-Waterman Alignment for Protein Database Search Using Frequency Distance Filtration Scheme Based on CPU-GPU Collaborative System. International Journal of Genomics. 2015;2015(761063):1–12. 10.1155/2015/761063 </plain></SENT>
</text></ref><ref id="pone.0157338.ref022"><text><SENT sid="551" pm="."><plain>22 ZhaoK, ChuX. G-BLASTN: accelerating nucleotide alignment by graphics processors. Bioinformatics. 2014;30(10):1384–1391. 10.1093/bioinformatics/btu047 <?supplied-pmid 24463183?>24463183 </plain></SENT>
</text></ref><ref id="pone.0157338.ref023"><text><SENT sid="552" pm="."><plain>23 LiuY, SchmidtB. CUSHAW2-GPU: Empowering Faster Gapped Short-Read Alignment Using GPU Computing. Design Test, IEEE. 2014;31(1):31–39. 10.1109/MDAT.2013.2284198 </plain></SENT>
</text></ref><ref id="pone.0157338.ref024"><text><SENT sid="553" pm="."><plain>24 PearsonWR. Searching protein sequence libraries: Comparison of the sensitivity and selectivity of the Smith-Waterman and FASTA algorithms. Genomics. 1991;11(3):635–650. 10.1016/0888-7543(91)90071-L <?supplied-pmid 1774068?>1774068 </plain></SENT>
</text></ref><ref id="pone.0157338.ref025"><text><SENT sid="554" pm="."><plain>25 MorgulisA, CoulourisG, RaytselisY, MaddenTL, AgarwalaR, SchäfferAA. Database indexing for production MegaBLAST searches. Bioinformatics. 2008;24(16):1757–1764. 10.1093/bioinformatics/btn322 <?supplied-pmid 18567917?>18567917 </plain></SENT>
</text></ref><ref id="pone.0157338.ref026"><text><SENT sid="555" pm="."><plain>26 VouzisPD, SahinidisNV. GPU-BLAST: using graphics processors to accelerate protein sequence alignment. Bioinformatics. 2011;27(2):182–188. 10.1093/bioinformatics/btq644 <?supplied-pmid 21088027?>21088027 </plain></SENT>
</text></ref><ref id="pone.0157338.ref027"><text><SENT sid="556" pm="."><plain>27 LiuW, SchmidtB, Muller-WittigW. CUDA-BLASTP: Accelerating BLASTP on CUDA-Enabled Graphics Hardware. IEEE/ACM Trans Comput Biol Bioinformatics. 2011;8(6):1678–1684. 10.1109/TCBB.2011.33 </plain></SENT>
</text></ref><ref id="pone.0157338.ref028"><text><SENT sid="557" pm="."><plain>28 FuL, NiuB, ZhuZ, WuS, LiW. CD-HIT: accelerated for clustering the next-generation sequencing data. Bioinformatics. 2012;28(23):3150–3152. 10.1093/bioinformatics/bts565 <?supplied-pmid 23060610?>23060610 </plain></SENT>
</text></ref><ref id="pone.0157338.ref029"><text><SENT sid="558" pm="."><plain>29 ChandoniaJ, HonG, WalkerNS, Lo ConteL, KoehlP, LevittM, et al The ASTRAL Compendium in 2004. Nucleic Acids Research. 2004;32(suppl 1):D189–D192. 10.1093/nar/gkh034 <?supplied-pmid 14681391?>14681391 </plain></SENT>
</text></ref><ref id="pone.0157338.ref030"><text><SENT sid="559" pm="."><plain>30 MurzinAG, BrennerSE, HubbardT, ChothiaC. SCOP: A structural classification of proteins database for the investigation of sequences and structures. Journal of Molecular Biology. 1995;247(4):536–540. 10.1016/S0022-2836(05)80134-2 <?supplied-pmid 7723011?>7723011 </plain></SENT>
</text></ref></ref-list></SecTag></back></article>
